#pragma once
#include "./c_arch.h"
#include "./c_interp.c"
#include "./lib/fmt.c"
#include "./lib/misc.h"
#include <mach/mach.h>
#include <stdio.h>

extern const Instr asm_call_forth_epilogue __asm__("asm_call_forth_epilogue");
extern const Instr asm_call_forth_trace __asm__("asm_call_forth_trace");

#define SYS_REC_FMT "[system] [recovery] "
#define UNWIND_CTX_FMT "; frame " FMT_UINT " = %p, callee = %p"
#define UNWIND_CTX_INP frame_ind, frame, callee

// Darwin-specific. TODO better segregation of CPU stuff vs OS stuff.
typedef struct {
  U64 x[29];
  U64 fp;
  U64 lr;
  U64 sp;
  U64 pc;
  U32 cpsr;
  U32 pad;
} Thread_state;

/*
We redefine the fields using same-sized but differently-typed
and differently-named integer types for better repr printing.
*/
static_assert(sizeof(Thread_state) == sizeof(arm_thread_state64_t));

/*
Used in unwinding. Reference:

  https://github.com/ARM-software/abi-aa/blob/c51addc3dc03e73a016a1e4edf25440bcac76431/aapcs64/aapcs64.rst#646the-frame-pointer
*/
typedef struct Frame_record {
  struct Frame_record *parent;
  const Instr         *caller;
} Frame_record;

static void Thread_state_repr(const Thread_state *val) {
  eprint_struct_beg(val, const Thread_state);
  eprint_struct_field_hint(val, x[0], " // error register");
  eprint_struct_field(val, x[1]);
  eprint_struct_field(val, x[2]);
  eprint_struct_field(val, x[3]);
  eprint_struct_field(val, x[4]);
  eprint_struct_field(val, x[5]);
  eprint_struct_field(val, x[6]);
  eprint_struct_field(val, x[7]);
  eprint_struct_field(val, x[8]);
  eprint_struct_field(val, x[9]);
  eprint_struct_field(val, x[10]);
  eprint_struct_field(val, x[11]);
  eprint_struct_field(val, x[12]);
  eprint_struct_field(val, x[13]);
  eprint_struct_field(val, x[14]);
  eprint_struct_field(val, x[15]);
  eprint_struct_field(val, x[16]);
  eprint_struct_field(val, x[17]);
  eprint_struct_field(val, x[18]);
  eprint_struct_field(val, x[19]);
  eprint_struct_field(val, x[20]);
  eprint_struct_field(val, x[21]);
  eprint_struct_field(val, x[22]);
  eprint_struct_field(val, x[23]);
  eprint_struct_field(val, x[24]);
  eprint_struct_field(val, x[25]);
  eprint_struct_field_hint(val, x[26], " // stack floor register");
  eprint_struct_field_hint(val, x[27], " // stack top register");
  eprint_struct_field_hint(val, x[28], " // interpreter register");
  eprint_struct_field(val, fp);
  eprint_struct_field(val, lr);
  eprint_struct_field(val, sp);
  eprint_struct_field(val, pc);
  eprint_struct_field(val, cpsr);
  eprint_struct_field(val, pad);
  eprint_struct_end();
}

static Err err_unwind_no_frame() {
  return err_str("unable to unwind: FP register is zero");
}

static Err err_unwind_empty_frame(const Frame_record *frame) {
  return errf("unable to unwind: frame record at address %p is empty", frame);
}

static Err err_unwind_internal_no_parent(
  const Frame_record *frame, Uint frame_ind, const void *callee
) {
  return errf(
    "unable to unwind: internal error: frame record does not refer to a parent frame" UNWIND_CTX_FMT,
    UNWIND_CTX_INP
  );
}

static Err err_unwind_internal_no_caller(
  const Frame_record *frame, Uint frame_ind, const void *callee
) {
  return errf(
    "unable to unwind: internal error: frame record does not have a caller instruction to return to" UNWIND_CTX_FMT,
    UNWIND_CTX_INP
  );
}

static Err err_unwind_internal_direction(
  const Frame_record *frame, Uint frame_ind, const void *callee
) {
  return errf(
    "unable to unwind: internal error: frame record refers to a parent frame at a lower address" UNWIND_CTX_FMT,
    UNWIND_CTX_INP
  );
}

static Err err_unwind_no_epilogue(const Frame_record *frame, const void *pc_new) {
  return errf(
    "unable to unwind: outer PC %p doesn't match epilogue address %p; frame: %p; parent: %p; caller: %p",
    pc_new,
    &asm_call_forth_epilogue,
    frame,
    frame->parent,
    frame->caller
  );
}

static Err err_unwind_invalid_stack(
  const Frame_record *frame, const void *sp_new, const void *pc_new
) {
  return errf(
    "unable to unwind: memory at the deduced SP %p has unexpected values, indicating invalid SP after unwinding; PC: %p; frame: %p; parent: %p; caller: %p",
    sp_new,
    pc_new,
    frame,
    frame->parent,
    frame->caller
  );
}

/*
We use this for Forth stack underflow / overflow exceptions which occur in
machine code generated by Forth procedures on the fly. The exceptions are
triggered by the CPU and delivered by Darwin to the handling thread.
Regular Forth exceptions use local gotos and don't involve this at all.

We get to "cheat" by making a few simplifying assumptions:

- Forth doesn't have `catch` (yet).
- Forth doesn't have `defer` (yet).
- Resource cleanup is not necessary.
- If the faulty PC is in Forth, one ancestor is `asm_call_forth`.
*/
static Err mach_unwind_thread(
  const Interp *interp, const char *msg, Thread_state *state
) {
  const auto code   = &interp->comp.code;
  auto       frame  = (Frame_record *)state->fp;
  const auto pc_old = (const Instr *)state->pc;
  auto       pc_new = pc_old;

  if (!frame) return err_unwind_no_frame();
  if (!frame->parent && !frame->caller) return err_unwind_empty_frame(frame);

  const auto leaf_lr = (const Instr *)state->lr;

  // Leaf procedure without its own frame record.
  if (comp_code_is_instr_ours(code, pc_new) && frame->caller != leaf_lr) {
    IF_DEBUG(eprintf(
      "[system] [unwind] frame -1: leaf procedure without a frame; PC: %p -> %p; LR: %p -> %p\n",
      pc_new,
      leaf_lr,
      (void *)state->lr,
      frame->caller
    ));

    /*
    Note: when doing this, we must also modify the LR;
    we do this unconditionally at the end of unwinding,
    using the last found frame.
    */
    pc_new = leaf_lr;
  }

  Uint frame_ind = 0;

  while (comp_code_is_instr_ours(code, pc_new)) {
    if (!frame->parent) {
      return err_unwind_internal_no_parent(frame, frame_ind, pc_new);
    }
    if (!frame->caller) {
      return err_unwind_internal_no_caller(frame, frame_ind, pc_new);
    }
    if (!(frame->parent > frame)) {
      return err_unwind_internal_direction(frame, frame_ind, pc_new);
    }

    IF_DEBUG({
      eprintf("[system] [unwind] frame " FMT_UINT " %p: ", frame_ind, frame);
      repr_struct(frame);
    });

    pc_new = frame->caller;
    frame  = frame->parent;
    frame_ind++;
  }

  IF_DEBUG({
    if (frame_ind) {
      eprintf(
        "[system] [unwind] final frame " FMT_UINT " %p: ", frame_ind, frame
      );
    }
    else {
      eprintf("[system] [unwind] frame %p: ", frame);
    }
    repr_struct(frame);
  });

  if (pc_new != &asm_call_forth_epilogue) {
    return err_unwind_no_epilogue(frame, pc_new);
  }

  pc_new = &asm_call_forth_trace;

  /*
  Finally, we need to restore the SP. Since we're returning
  to the trampoline, we can simply use its FP as the basis.
  */
  const auto sp_new = (const U64 *)frame - 4;

  // SYNC[asm_magic].
  const auto sp_ok = sp_new[1] == 0xABCD'FEED'ABCD'FACE;
  if (!sp_ok) {
    eprintf(
      "[system] [unwind] memory at SP %p:\n"
      "  %p: 0x%0.16llx 0x%0.16llx\n"
      "  %p: 0x%0.16llx 0x%0.16llx\n"
      "  %p: 0x%0.16llx 0x%0.16llx\n"
      "  %p: 0x%0.16llx 0x%0.16llx\n",
      sp_new,
      sp_new,
      sp_new[0],
      sp_new[1],
      sp_new + 2,
      sp_new[2],
      sp_new[3],
      sp_new + 4,
      sp_new[4],
      sp_new[5],
      sp_new + 6,
      sp_new[6],
      sp_new[7]
    );
    fflush(stderr);
    return err_unwind_invalid_stack(frame, sp_new, pc_new);
  }

  assign_cast(&state->fp, frame);
  assign_cast(&state->lr, frame->caller);
  assign_cast(&state->sp, sp_new);
  assign_cast(&state->pc, pc_new);
  assign_cast(&state->x[ASM_ERR_REG], msg);
  return nullptr;

  /*
  Partial sketch for returning to a catch handler.

    const auto sym = find_sym_by_instr(&interp->syms, bad_pc);
    if (!sym) {
      eprintf(
        SYS_REC_FMT "unable to find symbol for instruction %p\n", bad_pc
      );
      return KERN_FAILURE;
    }

    const auto epi   = asm_sym_epilogue_executable(&interp->asm, sym);
    const auto under = bad_addr < (void *)ints->floor;
    const auto dir   = under ? "underflow" : "overflow";

    const auto err = errf(
      "integer stack %s in word " FMT_QUOTED, dir, sym->name.buf
    );
  */
}

/*
`EXC_MASK_BAD_ACCESS` is sometimes recoverable; when it's an overflow or
underflow of the Forth integer stack, we can assume that the thread state
is otherwise not corrupted. We then modify the thread state to convert this
to a Forth exception. When the thread resumes, the error bubbles up to C.

TODO: if we ever bother to support the x64 architecture, we should specify
`EXC_ARITHMETIC` for division by zero and convert it to a Forth exception.

When initing the exception port, it should be safe to specify unsupported
exception types; we simply print thread state and don't handle the exception.
*/
kern_return_t catch_mach_exception_raise_state(
  mach_port_t                 exception_port,
  exception_type_t            exception,
  const mach_exception_data_t code,
  mach_msg_type_number_t      code_len,
  int                        *flavor,
  const thread_state_t        state_prev_ptr,
  mach_msg_type_number_t      state_prev_len,
  thread_state_t              state_next_ptr,
  mach_msg_type_number_t     *state_next_len
) {
  (void)exception_port;

  constexpr auto state_chunk_size = sizeof(*(thread_state_t) nullptr);
  constexpr auto state_len        = sizeof(Thread_state) / state_chunk_size;
  static_assert(!(sizeof(Thread_state) % state_chunk_size));

  if (code_len != 2) return MIG_BAD_ARGUMENTS;
  if (*flavor != ARM_THREAD_STATE64) return KERN_FAILURE;
  if (state_prev_len != state_len) return MIG_BAD_ARGUMENTS;

  const auto state  = (Thread_state *)state_prev_ptr;
  const auto interp = (Interp *)state->x[ASM_REG_INTERP];

  IF_DEBUG({
    eprintf(SYS_REC_FMT "bad thread state: ");
    Thread_state_repr(state);
    eprintf(SYS_REC_FMT "code[0]: %p\n", (void *)code[0]);
    eprintf(SYS_REC_FMT "code[1]: %p (bad address)\n", (void *)code[1]);
    eprintf(SYS_REC_FMT "interpreter address: %p\n", interp);
    fflush(stderr);
  });

  if (!interp_valid(interp)) {
    IF_DEBUG({
      eprintf(
        SYS_REC_FMT
        "address %p recovered from register %d does not appear to reference valid interpreter state\n",
        interp,
        ASM_REG_INTERP
      );
      fflush(stderr);
    });
    return KERN_FAILURE;
  }

  if (exception != EXC_BAD_ACCESS) return KERN_FAILURE;

  const auto  comp      = &interp->comp;
  const auto  bad_addr  = (void *)code[1]; // undocumented
  const auto  ints      = &interp->ints;
  const void *ints_low  = ints->cellar;
  const void *ints_high = (U8 const *)ints_low + ints->bytelen;

  if (!(bad_addr >= ints_low && bad_addr < ints_high)) {
    eprintf(SYS_REC_FMT "bad access at address %p\n", bad_addr);
    eputs(SYS_REC_FMT "known valid address ranges:");
    eprintf(
      SYS_REC_FMT "  integer    stack:        [%p,%p)\n", ints->floor, ints->ceil
    );
    eprintf(
      SYS_REC_FMT "  writable   instructions: [%p,%p)\n",
      comp->code.code_write.dat,
      list_len_ceil(&comp->code.code_write)
    );
    eprintf(
      SYS_REC_FMT "  executable instructions: [%p,%p)\n",
      comp->code.code_exec.dat,
      list_len_ceil(&comp->code.code_exec)
    );
    fflush(stderr);
    return KERN_FAILURE;
  }

  const auto bad_pc = (void *)state->pc;
  const auto under  = bad_addr < (void *)ints->floor;
  const auto msg = under ? "integer stack underflow" : "integer stack overflow";

  IF_DEBUG({
    eprintf(SYS_REC_FMT "detected %s\n", msg);
    fflush(stderr);
  });

  const auto err = mach_unwind_thread(interp, msg, state);
  if (err) {
    eprintf(SYS_REC_FMT "%s\n", err);
    fflush(stderr);
    return KERN_FAILURE;
  }

  if (bad_pc == bad_addr) return KERN_FAILURE;

  memcpy(state_next_ptr, state, sizeof(*state));
  *state_next_len = state_len;

  // IF_DEBUG({
  //   eprintf(SYS_REC_FMT "updated thread state: ");
  //   Thread_state_repr((const Thread_state *)state_next_ptr);
  //   fflush(stderr);
  // });

  return KERN_SUCCESS;
}
